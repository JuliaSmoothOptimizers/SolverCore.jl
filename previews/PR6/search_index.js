var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#Contents","page":"Reference","title":"Contents","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [SolverCore]","category":"page"},{"location":"reference/#SolverCore.AbstractSolver","page":"Reference","title":"SolverCore.AbstractSolver","text":"AbstractSolver{T,S}\n\nBase type for JSO-compliant solvers.\n\nA solver must have three members:\n\ninitialized :: Bool, indicating whether the solver was initialized\nparams :: Dict, a dictionary of parameters for the solver\nworkspace, a named tuple with arrays used by the solver.\n\nThe type T is used for element types of the arrays, and S is used for the storage container type.\n\n\n\n\n\n","category":"type"},{"location":"reference/#SolverCore.AbstractSolverOutput","page":"Reference","title":"SolverCore.AbstractSolverOutput","text":"AbstractSolverOutput{T,S}\n\nBase type for output of JSO-compliant solvers. An output must have at least the following:\n\nstatus :: Symbol\nsolution\n\nThe type T is used for element types of the arrays, and S is used for the storage container type.\n\n\n\n\n\n","category":"type"},{"location":"reference/#SolverCore.are_valid_parameters","page":"Reference","title":"SolverCore.are_valid_parameters","text":"are_valid_parameters(solver, args...)\n\nReturn whether the parameters given in args are valid for solver. The order of the parameters must be the same as in parameters(solver).\n\nSolvers should define\n\nSolverCore.are_valid_parameters(::Type{Solver{T}}, arg1, arg2, ...) where T\n\n\n\n\n\n","category":"function"},{"location":"reference/#SolverCore.can_solve_type-Union{Tuple{S}, Tuple{Type{S}, Symbol}} where S<:AbstractSolver","page":"Reference","title":"SolverCore.can_solve_type","text":"can_solve_type(solver, type)\n\nCheck if the solver can solve problems of type. Call problem_types_handled for a list of problem types that the solver can solve.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SolverCore.grid_search_tune-Union{Tuple{Solver}, Tuple{Type{Solver}, Any}} where Solver<:AbstractSolver","page":"Reference","title":"SolverCore.grid_search_tune","text":"solver, results = grid_search_tune(SolverType, problems; kwargs...)\n\nSimple tuning of solver SolverType by grid search, on problems, which should be iterable. The following keyword arguments are available:\n\nsuccess: A function to be applied on a solver output that returns whether the problem has terminated succesfully. Defaults to o -> o.status == :first_order.\ncosts: A vector of cost functions and penalties. Each element is a tuple of two elements. The first is a function to be applied to the output of the solver, and the second is the cost when the solver fails (see success above) or throws an error. Defaults to\n\n[\n  (o -> o.elapsed_time, 100.0),\n  (o -> o.counters.neval_obj + o.counters.neval_cons, 1000),\n  (o -> !success(o), 1),\n]\n\nwhich represent the total elapsed_time (with a penalty of 100.0 for failures); the number of objective and constraints functions evaluations (with a penalty of 1000 for failures); and the number of failures.\n\ngrid_length: The number of points in the ranges of the grid for continuous points.\nsolver_kwargs: Arguments to be passed to the solver. Note: use this to set the stopping parameters, but not the other parameters being optimize.\nAny parameters accepted by the Solver: a range to be used instead of the default range.\n\nThe default ranges are based on the parameters types, and are as follows:\n\n:real: linear range from :min to :max with grid_length points.\n:log: logarithmic range from :min to :max with grid_length points. Computed by exp of linear range of log(:min) to log(:max).\n:bool: either false or true.\n:int: integer range from :min to :max.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SolverCore.log_header-Tuple{AbstractVector{Symbol}, AbstractVector{DataType}}","page":"Reference","title":"SolverCore.log_header","text":"log_header(colnames, coltypes)\n\nCreates a header using the names in colnames formatted according to the types in coltypes. Uses internal formatting specification given by SolverCore.formats and default header translation given by SolverCore.default_headers.\n\nInput:\n\ncolnames::Vector{Symbol}: Column names.\ncoltypes::Vector{DataType}: Column types.\n\nKeyword arguments:\n\nhdr_override::Dict{Symbol,String}: Overrides the default headers.\ncolsep::Int: Number of spaces between columns (Default: 2)\n\nSee also log_row.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SolverCore.log_row-Tuple{Any}","page":"Reference","title":"SolverCore.log_row","text":"log_row(vals)\n\nCreates a table row from the values on vals according to their types. Pass the names and types of vals to log_header for a logging table. Uses internal formatting specification given by SolverCore.formats.\n\nTo handle a missing value, add the type instead of the number:\n\n@info log_row(Any[1.0, 1])\n@info log_row(Any[Float64, Int])\n\nPrints\n\n[ Info:  1.0e+00       1\n[ Info:        -       -\n\nKeyword arguments:\n\ncolsep::Int: Number of spaces between columns (Default: 2)\n\n\n\n\n\n","category":"method"},{"location":"reference/#SolverCore.parameters","page":"Reference","title":"SolverCore.parameters","text":"named_tuple = parameters(solver)\nnamed_tuple = parameters(SolverType)\nnamed_tuple = parameters(SolverType{T})\n\nReturn the parameters of a solver, or of the type SolverType. You can specify the type T of the SolverType. The returned structure is a nested NamedTuple. Each key of named_tuple is the name of a parameter, and its value is a NamedTuple containing\n\ndefault: The default value of the parameter.\ntype: The type of the parameter, such as Int, Float64, T, etc.\n\nand possibly other values depending on the type. Some possibilies are:\n\nscale: How to explore the domain\n:linear: A continuous value within a range\n:log: A positive continuous value that should be explored logarithmically (like 10⁻², 10⁻¹, 1, 10).\nmin: Minimum value.\nmax: Maximum value.\n\nSolvers should define\n\nSolverCore.parameters(::Type{Solver{T}}) where T\n\n\n\n\n\n","category":"function"},{"location":"reference/#SolverCore.problem_types_handled-Tuple{Type{var\"#s8\"} where var\"#s8\"<:AbstractSolver}","page":"Reference","title":"SolverCore.problem_types_handled","text":"problem_types_handled(solver)\n\nList the problem types handled by the solver.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SolverCore.solve!","page":"Reference","title":"SolverCore.solve!","text":"output = solve!(solver, problem)\n\nSolve problem with solver.\n\n\n\n\n\n","category":"function"},{"location":"#Home","page":"Home","title":"SolverCore.jl documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Core package to build JSO-compliant solvers in Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package is extended for specific problem types:","category":"page"},{"location":"","page":"Home","title":"Home","text":"OptSolver.jl: For optimization problems\nLinearSolvers.jl: For linear solvers.","category":"page"}]
}
