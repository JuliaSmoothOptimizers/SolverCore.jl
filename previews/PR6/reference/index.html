<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · SolverCore.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/style.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="SolverCore.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">SolverCore.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaSmoothOptimizers/SolverCore.jl/blob/master/docs/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><ul><li><a href="#Reference">Reference</a></li><ul><li><a href="#Contents">Contents</a></li><li><a href="#Index">Index</a></li></ul></ul><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#SolverCore.AbstractSolver"><code>SolverCore.AbstractSolver</code></a></li><li><a href="#SolverCore.AbstractSolverOutput"><code>SolverCore.AbstractSolverOutput</code></a></li><li><a href="#SolverCore.are_valid_parameters"><code>SolverCore.are_valid_parameters</code></a></li><li><a href="#SolverCore.can_solve_type-Union{Tuple{S}, Tuple{Type{S}, Symbol}} where S&lt;:AbstractSolver"><code>SolverCore.can_solve_type</code></a></li><li><a href="#SolverCore.grid_search_tune-Union{Tuple{Solver}, Tuple{Type{Solver}, Any}} where Solver&lt;:AbstractSolver"><code>SolverCore.grid_search_tune</code></a></li><li><a href="#SolverCore.log_header-Tuple{AbstractVector{Symbol}, AbstractVector{DataType}}"><code>SolverCore.log_header</code></a></li><li><a href="#SolverCore.log_row-Tuple{Any}"><code>SolverCore.log_row</code></a></li><li><a href="#SolverCore.parameters"><code>SolverCore.parameters</code></a></li><li><a href="#SolverCore.problem_types_handled-Tuple{Type{var&quot;#s8&quot;} where var&quot;#s8&quot;&lt;:AbstractSolver}"><code>SolverCore.problem_types_handled</code></a></li><li><a href="#SolverCore.solve!"><code>SolverCore.solve!</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="SolverCore.AbstractSolver" href="#SolverCore.AbstractSolver"><code>SolverCore.AbstractSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractSolver{T,S}</code></pre><p>Base type for JSO-compliant solvers.</p><p>A solver must have three members:</p><ul><li><code>initialized :: Bool</code>, indicating whether the solver was initialized</li><li><code>params :: Dict</code>, a dictionary of parameters for the solver</li><li><code>workspace</code>, a named tuple with arrays used by the solver.</li></ul><p>The type <code>T</code> is used for element types of the arrays, and <code>S</code> is used for the storage container type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/SolverCore.jl/blob/797c25bbdbbf211fbe5e9ac1c51f032fe82defdb/src/solver.jl#L4-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolverCore.AbstractSolverOutput" href="#SolverCore.AbstractSolverOutput"><code>SolverCore.AbstractSolverOutput</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractSolverOutput{T,S}</code></pre><p>Base type for output of JSO-compliant solvers. An output must have at least the following:</p><ul><li><code>status :: Symbol</code></li><li><code>solution</code></li></ul><p>The type <code>T</code> is used for element types of the arrays, and <code>S</code> is used for the storage container type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/SolverCore.jl/blob/797c25bbdbbf211fbe5e9ac1c51f032fe82defdb/src/output.jl#L4-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolverCore.are_valid_parameters" href="#SolverCore.are_valid_parameters"><code>SolverCore.are_valid_parameters</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">are_valid_parameters(solver, args...)</code></pre><p>Return whether the parameters given in <code>args</code> are valid for <code>solver</code>. The order of the parameters must be the same as in <code>parameters(solver)</code>.</p><p>Solvers should define</p><pre><code class="language-none">SolverCore.are_valid_parameters(::Type{Solver{T}}, arg1, arg2, ...) where T</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/SolverCore.jl/blob/797c25bbdbbf211fbe5e9ac1c51f032fe82defdb/src/parameters.jl#L33-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolverCore.can_solve_type-Union{Tuple{S}, Tuple{Type{S}, Symbol}} where S&lt;:AbstractSolver" href="#SolverCore.can_solve_type-Union{Tuple{S}, Tuple{Type{S}, Symbol}} where S&lt;:AbstractSolver"><code>SolverCore.can_solve_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">can_solve_type(solver, type)</code></pre><p>Check if the <code>solver</code> can solve problems of <code>type</code>. Call <code>problem_types_handled</code> for a list of problem types that the <code>solver</code> can solve.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/SolverCore.jl/blob/797c25bbdbbf211fbe5e9ac1c51f032fe82defdb/src/traits.jl#L11-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolverCore.grid_search_tune-Union{Tuple{Solver}, Tuple{Type{Solver}, Any}} where Solver&lt;:AbstractSolver" href="#SolverCore.grid_search_tune-Union{Tuple{Solver}, Tuple{Type{Solver}, Any}} where Solver&lt;:AbstractSolver"><code>SolverCore.grid_search_tune</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">solver, results = grid_search_tune(SolverType, problems; kwargs...)</code></pre><p>Simple tuning of solver <code>SolverType</code> by grid search, on <code>problems</code>, which should be iterable. The following keyword arguments are available:</p><ul><li><code>success</code>: A function to be applied on a solver output that returns whether the problem has terminated succesfully. Defaults to <code>o -&gt; o.status == :first_order</code>.</li><li><code>costs</code>: A vector of cost functions and penalties. Each element is a tuple of two elements. The first is a function to be applied to the output of the solver, and the second is the cost when the solver fails (see <code>success</code> above) or throws an error. Defaults to</li></ul><pre><code class="language-none">[
  (o -&gt; o.elapsed_time, 100.0),
  (o -&gt; o.counters.neval_obj + o.counters.neval_cons, 1000),
  (o -&gt; !success(o), 1),
]</code></pre><p>which represent the total elapsed_time (with a penalty of 100.0 for failures); the number of objective and constraints functions evaluations (with a penalty of 1000 for failures); and the number of failures.</p><ul><li><code>grid_length</code>: The number of points in the ranges of the grid for continuous points.</li><li><code>solver_kwargs</code>: Arguments to be passed to the solver. Note: use this to set the stopping parameters, but not the other parameters being optimize.</li><li>Any parameters accepted by the <code>Solver</code>: a range to be used instead of the default range.</li></ul><p>The default ranges are based on the parameters types, and are as follows:</p><ul><li><code>:real</code>: linear range from <code>:min</code> to <code>:max</code> with <code>grid_length</code> points.</li><li><code>:log</code>: logarithmic range from <code>:min</code> to <code>:max</code> with <code>grid_length</code> points. Computed by exp of linear range of <code>log(:min)</code> to <code>log(:max)</code>.</li><li><code>:bool</code>: either <code>false</code> or <code>true</code>.</li><li><code>:int</code>: integer range from <code>:min</code> to <code>:max</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/SolverCore.jl/blob/797c25bbdbbf211fbe5e9ac1c51f032fe82defdb/src/grid-search-tuning.jl#L7-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolverCore.log_header-Tuple{AbstractVector{Symbol}, AbstractVector{DataType}}" href="#SolverCore.log_header-Tuple{AbstractVector{Symbol}, AbstractVector{DataType}}"><code>SolverCore.log_header</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">log_header(colnames, coltypes)</code></pre><p>Creates a header using the names in <code>colnames</code> formatted according to the types in <code>coltypes</code>. Uses internal formatting specification given by <code>SolverCore.formats</code> and default header translation given by <code>SolverCore.default_headers</code>.</p><p>Input:</p><ul><li><code>colnames::Vector{Symbol}</code>: Column names.</li><li><code>coltypes::Vector{DataType}</code>: Column types.</li></ul><p>Keyword arguments:</p><ul><li><code>hdr_override::Dict{Symbol,String}</code>: Overrides the default headers.</li><li><code>colsep::Int</code>: Number of spaces between columns (Default: 2)</li></ul><p>See also <a href="#SolverCore.log_row-Tuple{Any}"><code>log_row</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/SolverCore.jl/blob/797c25bbdbbf211fbe5e9ac1c51f032fe82defdb/src/logger.jl#L33-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolverCore.log_row-Tuple{Any}" href="#SolverCore.log_row-Tuple{Any}"><code>SolverCore.log_row</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">log_row(vals)</code></pre><p>Creates a table row from the values on <code>vals</code> according to their types. Pass the names and types of <code>vals</code> to <a href="#SolverCore.log_header-Tuple{AbstractVector{Symbol}, AbstractVector{DataType}}"><code>log_header</code></a> for a logging table. Uses internal formatting specification given by <code>SolverCore.formats</code>.</p><p>To handle a missing value, add the type instead of the number:</p><pre><code class="language-none">@info log_row(Any[1.0, 1])
@info log_row(Any[Float64, Int])</code></pre><p>Prints</p><pre><code class="language-none">[ Info:  1.0e+00       1
[ Info:        -       -</code></pre><p>Keyword arguments:</p><ul><li><code>colsep::Int</code>: Number of spaces between columns (Default: 2)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/SolverCore.jl/blob/797c25bbdbbf211fbe5e9ac1c51f032fe82defdb/src/logger.jl#L70-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolverCore.parameters" href="#SolverCore.parameters"><code>SolverCore.parameters</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">named_tuple = parameters(solver)
named_tuple = parameters(SolverType)
named_tuple = parameters(SolverType{T})</code></pre><p>Return the parameters of a <code>solver</code>, or of the type <code>SolverType</code>. You can specify the type <code>T</code> of the <code>SolverType</code>. The returned structure is a nested NamedTuple. Each key of <code>named_tuple</code> is the name of a parameter, and its value is a NamedTuple containing</p><ul><li><code>default</code>: The default value of the parameter.</li><li><code>type</code>: The type of the parameter, such as <code>Int</code>, <code>Float64</code>, <code>T</code>, etc.</li></ul><p>and possibly other values depending on the <code>type</code>. Some possibilies are:</p><ul><li><code>scale</code>: How to explore the domain<ul><li><code>:linear</code>: A continuous value within a range</li><li><code>:log</code>: A positive continuous value that should be explored logarithmically (like 10⁻², 10⁻¹, 1, 10).</li></ul></li><li><code>min</code>: Minimum value.</li><li><code>max</code>: Maximum value.</li></ul><p>Solvers should define</p><pre><code class="language-none">SolverCore.parameters(::Type{Solver{T}}) where T</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/SolverCore.jl/blob/797c25bbdbbf211fbe5e9ac1c51f032fe82defdb/src/parameters.jl#L3-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolverCore.problem_types_handled-Tuple{Type{var&quot;#s8&quot;} where var&quot;#s8&quot;&lt;:AbstractSolver}" href="#SolverCore.problem_types_handled-Tuple{Type{var&quot;#s8&quot;} where var&quot;#s8&quot;&lt;:AbstractSolver}"><code>SolverCore.problem_types_handled</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">problem_types_handled(solver)</code></pre><p>List the problem types handled by the <code>solver</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/SolverCore.jl/blob/797c25bbdbbf211fbe5e9ac1c51f032fe82defdb/src/traits.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SolverCore.solve!" href="#SolverCore.solve!"><code>SolverCore.solve!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">output = solve!(solver, problem)</code></pre><p>Solve <code>problem</code> with <code>solver</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/SolverCore.jl/blob/797c25bbdbbf211fbe5e9ac1c51f032fe82defdb/src/solver.jl#L22-L26">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 18 April 2021 16:06">Sunday 18 April 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
